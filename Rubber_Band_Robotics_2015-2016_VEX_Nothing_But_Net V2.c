#pragma config(Sensor, in1,    SCpot,          sensorPotentiometer)
#pragma config(Sensor, in7,    expanderBatt,   sensorAnalog)
#pragma config(Sensor, dgtl1,  speed,          sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  ball,           sensorTouch)
#pragma config(Sensor, dgtl4,  driveEncoderleft, sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  driveEncoderright, sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  led,            sensorLEDtoVCC)
#pragma config(Sensor, dgtl10, Puncher,        sensorQuadEncoder)
#pragma config(Sensor, dgtl12, PuncherLimit,   sensorLEDtoVCC)
#pragma config(Motor,  port1,           leftLauncherBottom, tmotorVex393TurboSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           intakeBottom,  tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           rightDrive,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           leftPuncherTop, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           rightPuncherBottom, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           leftPuncherBottom, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           rightPuncherTop, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           leftDrive,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           intakeTop,     tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          leftLauncherTop, tmotorVex393TurboSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int RPMAverage2 = 0;
int RPMAverage = 0;
long launcherTemp111 = 0;
long launcherTemp222 = 0;
long launcherRPM = 0;
float Kp = 0.004;
float Kd = 0.05;
float Kp2left = 0.01;
float Kd2left = 0;
float Kp2right = 0.01;
float Kd2right = 0;
int error = 0;
int target = 3400;
int derivative = 0;
int previousError = 0;
int error2left = 0;
int target2left = 0;
int derivative2left = 0;
int previousError2left = 0;
int error2right = 0;
int target2right = 0;
int derivative2right = 0;
int previousError2right = 0;
int rampRPM = 2000;
float temp1 = 100;
float rampingSpeed = 0;
float PDout = 0;
int time = 0;
bool PDenabled = false;
bool controlEnabled = false;
bool launcherEnabled = false;
bool bangbangEnabled = false;
string mode2 = "disabled";
bool isAuton = false;
bool master = false;
string test;
int ballNumber = 0;
string auton;
string state;
const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;
//int stuff = 0;
//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Competition_Control.c"	 //Main competition background code...do not modify!




void setAllDrive(int speed)
{
	motor[leftDrive] = speed;
	motor[rightDrive] = speed;
}

void setLauncher(float speed)
{
	motor[leftLauncherBottom] = (int) speed;
	motor[leftLauncherTop] = (int) speed;
	//motor[rightLauncherBottom] = (int) speed;
	//motor[rightLauncherTop] = (int) speed;
}

void setPuncher(int speed)
{
	//motor[leftPuncherTop] = speed;
	//motor[leftPuncherbottom] = speed;
	//motor[rightPuncherTop] = speed;
	//motor[rightPuncherBottom] = speed;
}

void setIntake(int power)
{
	motor[intakeTop] = power;
	motor[intakeBottom] = power;
}

void rampDown()
{
	rampingSpeed = temp1;
	while(launcherRPM > 500)
	{
		rampingSpeed = (rampingSpeed - 1); //Should take about 5 seconds
		if(rampingSpeed < 10)
		{
			rampingSpeed = 10;
		}
		setLauncher(rampingSpeed);
		delay(50);
	}
	setLauncher(0);
}

void rampUp()
{
	rampingSpeed = 30;

	while(launcherRPM < rampRPM)
	{
		rampingSpeed = (rampingSpeed + 1); //Should take about 5 seconds
		setLauncher(rampingSpeed);
		delay(50);
	}
}
void waitForRelease(char * button)
{
	int number;
	if(button != "all")
	{
		if(button == "rightButton")
			number = 4;
		else if(button == "leftButton")
			number = 1;
		else if(button == "centerButton")
			number = 2;

		while(nLCDButtons == number)
			delay(5);
	}
	else
	{
		while(nLCDButtons != 0){}
		wait1Msec(5);
	}
}

//void waitForRelease()
//{
//	while(nLCDButtons != 0){}
//	wait1Msec(5);
//}

void setAuton (int override)
{
	int autonTemp = 1;
	while(nLCDButtons != centerButton && bIfiRobotDisabled)
	{
		clearLCDLine(0);
		clearLCDLine(1);
		if(nLCDButtons == leftButton)
		{
			if(autonTemp != 1)
			{
				autonTemp --;
			}
			waitForRelease("leftButton");
			//waitForRelease();
		}
		if(nLCDButtons == rightButton)
		{
			if(autonTemp != 3)
			{
				autonTemp ++;
			}
			waitForRelease("rightButton");
		}
		if(autonTemp == 1)
		{
			auton = "full_court_preloads";
		}
		else if(autonTemp == 2)
		{
			auton = "field_spin";
		}
		else if(autonTemp == 3)
		{
			auton = "none";
		}
		else if(autonTemp == 4)
		{
			auton = "field_preloads";
		}
		displayLCDString(0, 0, auton);
		delay(100);
	}
	waitForRelease("centerButton");
	while(nLCDButtons != centerButton && !bIfiAutonomousMode || (!bIfiAutonomousMode && !bIfiRobotDisabled))
	{
		clearLCDLine(0);
		clearLCDLine(1);
		displayLCDString(0, 0, "Preload");
		displayLCDString(1, 0, "OUT   Done    IN");
		if(nLCDButtons == leftButton)
			setIntake(-127);
		else if(nLCDButtons == rightButton)
			setIntake(127);
		else
			setIntake(0);
		delay(100);
	}
}


task launcherSpeedAverage()
{
	int RPMA1 = 0;
	int RPMA2 = 0;
	int RPMA3 = 0;
	int RPMA4 = 0;
	int RPMA5 = 0;
	int RPMA6 = 0;
	int RPMA7 = 0;
	int RPMA8 = 0;
	int RPMA9 = 0;
	int RPMA10 = 0;
	while(true)
	{
		for(int i = 0; i <= 9; i++)
		{
			RPMA10 = RPMA9;
			RPMA9 = RPMA8;
			RPMA8 = RPMA7;
			RPMA7 = RPMA6;
			RPMA6 = RPMA5;
			RPMA5 = RPMA4;
			RPMA4 = RPMA3;
			RPMA3 = RPMA2;
			RPMA2 = RPMA1;
			RPMA1 = launcherRPM;
			delay(50);
		}

		RPMAverage = ((RPMA1 + RPMA2 + RPMA3 + RPMA4 + RPMA5 + RPMA6 + RPMA7 + RPMA8 + RPMA9 + RPMA10) / 10);
	}
}

task launcherSpeedAverage2()
{
	int RPMA21 = 0;
	int RPMA22 = 0;
	int RPMA23 = 0;

	while(true)
	{
		for(int i = 0; i < 3; i++)
		{
			RPMA23 = RPMA22;
			RPMA22 = RPMA21;
			RPMA21 = launcherRPM;
			delay(50);
		}

		RPMAverage2 = ((RPMA21 + RPMA22 + RPMA23) / 3);
	}
}

task launcherSpeed()
{
	SensorValue[speed] = 0;
	int RPMA21 = 0;
	int RPMA22 = 0;
	int RPMA23 = 0;
	int number = 0;
	while(true)
	{
		launcherTemp111 = SensorValue[speed];

		delay(50);
		launcherTemp222 = (SensorValue[speed] - launcherTemp111);

		launcherRPM = (((launcherTemp222 * 1200) / 360) * (11 + 2/3));	//need to take into account gear ratio between launcher wheel
		//and sensor. also, do I need to worry about how long it takes to perform the above calculations?
		//what about how often the quad encoder updates?
		//should I unplug the second port because I dont need to know which way its going?
		RPMA23 = RPMA22;
		RPMA22 = RPMA21;
		RPMA21 = launcherRPM;
		delay(50);
		RPMAverage2 = ((RPMA21 + RPMA22 + RPMA23) / 3);
	}
}

task PD()
{
	error = 0;
	previousError = 0;

	while(true)
	{
		if(PDenabled == true)
		{
			error = target - RPMAverage2;

			derivative = error - previousError;

			previousError = error;

			PDout = (error * Kp) + (derivative * Kd);
		}

		delay(50);
	}
}

task control()
{

	while(true)
	{
		if(controlEnabled == true)
		{
			temp1 += PDout ;

			if(temp1 < 0)
			{
				temp1 = 0;
			}
			setLauncher(temp1);

			delay(100);

			if(temp1 > 127)
			{
				temp1 = 127;
			}
			else if(temp1 < -127)
			{
				temp1 = -127;
			}
		}
	}
}

task bangbang()
{
	while(true)
	{
		if(bangbangEnabled)
		{
			if(RPMAverage2 < target)
			{
				setLauncher(127);
			}
			else if(RPMAverage2 > target)
			{
				setLauncher(70);
			}
		}
		delay(10);
	}
}

task PD2()
{
	while(true)
	{
		error2left = target2left - SensorValue[driveEncoderleft];

		derivative2left = error2left - previousError2left;

		previousError2left = error2left;

		motor[leftDrive] = ((error2left * Kp2left) + (derivative2left * Kd2left));


		error2right = target2right - SensorValue[driveEncoderright];

		derivative2right = error2right - previousError2right;

		previousError2right = error2right;

		motor[leftDrive] = ((error2right * Kp2right) + (derivative2right * Kd2right));

		delay(50);
	}
}

task driveControl()
{
	while(true)
	{
		delay(50);
		if(vexRT[Btn8R] == 1)
		{
			ballNumber++;
			while(SensorValue[ball] == 1 && vexRT[Btn8R] == 1)
			{
				setIntake(-127);
				delay(10);
			}
			while(SensorValue[ball] == 0 && vexRT[Btn8R] == 1)
			{
				setIntake(-127);
				delay(10);
			}
			setIntake(10);
			delay(100);
			setIntake(0);
			delay(500);
			while(RPMAverage2 < 3100 && vexRT[Btn8R] == 1)
			{
				setIntake(0);
				delay(10);
			}
		}
		else
		{
			if(vexRT[Btn5U] == 1)
			{
				motor[intakeTop] = -127;
				//motor[intakeBottom] = -127;
			}
			else if(vexRT[Btn5D] == 1)
			{
				motor[intakeTop] = 127;
				//motor[intakeBottom] = 127;
			}
			else
			{
				motor[intakeTop] = 0;
				//motor[intakeBottom] = 0;
			}

			if(vexRT[Btn7L] == 1)
			{
				setPuncher(127);
			}
			else if(vexRT[Btn7R] == 1)
			{
				setPuncher(-60);
			}
			else
			{
				setPuncher(0);
			}

			if(vexRT[Btn6U] == 1)
			{
				motor[intakeBottom] = -127;
			}
			else if(vexRT[Btn6D] == 1)
			{
				motor[intakeBottom] = 127;
			}
			else
			{
				motor[intakeBottom] = 0;
			}
		}

		if(abs(vexRT[Ch3]) > 10)
		{
			motor[leftDrive] = vexRT[Ch3];
			//motor[leftDrive2] = vexRT[Ch3];
//			motor[leftRearDrive] = vexRT[Ch3];
		}
		else
		{
			motor[leftDrive] = 0;
			//motor[leftDrive2] = 0;
//			motor[leftRearDrive] = 0;
		}

		if(abs(vexRT[Ch2]) > 10)
		{
			motor[rightDrive] = vexRT[Ch2];
			//motor[rightDrive2] = vexRT[Ch2];
//			motor[rightRearDrive] = vexRT[Ch2];
		}
		else
		{
			motor[rightDrive] = 0;
			//motor[rightDrive2] = 0;
//			motor[rightRearDrive] = 0;
		}
		if(RPMAverage2 >= target - 100)
		{
			SensorValue[led] = 1;
		}
		else
		{
			SensorValue[led] = 0;
		}

		//if(vexRT[Btn8D] == 1)
		//{
		//	motor[leftLift] = 127;
		//	//motor[rightLift] = 127;
		//}
		//else if(vexRT[Btn8U] == 1)
		//{
		//	motor[leftLift] = -127;
		//	//motor[rightLift] = -127;
		//}
		//else
		//{
		//	motor[leftLift] = 0;
		//	//motor[rightLift] = 0;
		//}
	}
}

task distance()
{
	while(true)
	{
		if(vexRT[Btn8U] == 1)
		{
			target = 2800;
		}
		else if(vexRT[Btn8D] == 1)
		{
			target = 2500;
		}
		else if(vexRT[Btn8L] == 1)
		{
			target = 2000;
		}

		state = nVexRCReceiveState;
		delay(50);
	}
}



task launcherMaster()
{
//PDenabled = false;
//controlEnabled = false;
//	int suff = 9001;
master = true;
while(true)
{

	//mode == "usercontrol"
	if(!isAuton)
	{
		while(vexRT[Btn7U] == 0)
		{
			delay(100);
		}
		time1[T1] = 0;

		rampUp();
		bangbangEnabled = true;

		while(vexRT[Btn7D] == 0)
		{
			delay(100);
		}

		bangbangEnabled = false;
		rampDown();
	}
	else if(isAuton)
	{
		while(launcherEnabled == false && isAuton)
		{
			delay(100);
		}
		time1[T1] = 0;

		rampUp();
		bangbangEnabled = true;

		while(launcherEnabled == true && isAuton)
		{
			delay(100);
		}

		rampDown();
		bangbangEnabled = false;
	}


}

}

task timers()
{
while(true)
{
	delay(1000);
	time = time + 1;

}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//													Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////
int blahblah = 0;
void pre_auton()														//I might need to move the pre_auton call in the Vex_Competition_includes to line 54 instead
//of line 61.
{
mode2 = "preAuton";
bStopTasksBetweenModes = false;

//motor[launcherAngleAdjust] = -50;					//Can I move motors in preauton? should I move the call to it in Vex_Competition_includes to a
//waitUntil(SensorValue[angleReset] == 1);	//different spot?
//motor[launcherAngleAdjust] = 0;
//SensorValue[launcherAngle] = 0;

mode2 = "afterPreAuton";
blahblah = 1;

setAuton(0);

blahblah = 2;



}

/////////////////////////////////////////////////////////////////////////////////////////
//
//																 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
isAuton = true;
startTask(launcherMaster);							//All of this is for the launcher, and for diagnostics
startTask(bangbang);
//PDenabled = false;
//startTask(PD2);
//startTask(PD);
//startTask(control);
startTask(launcherSpeed);
//startTask(launcherSpeedAverage);
//startTask(launcherSpeedAverage2);
startTask(timers);
mode2 = autonomous;
time = 0;
clearLCDLine(0);
clearLCDLine(1);


delay(100);


test = "AUTON_RUNNING";

if(auton == "full_court_preloads")
{
	for(int i = 0; i < 4; i++)
	{
		SensorValue[Puncher] = 0;
		while(SensorValue[Puncher] < 360)
		setPuncher(127);

		delay(1000);
	}

}
else if(auton == "field_spin")
{
	startTask(PD2);
	target2left = 0; 									//Need to give this an actual value
	target2right = 0;
	delay(500);
	while(error2left > 100 && error2right > 100)
		delay(100);

	setAllDrive(-15);
	delay(200);
	setAllDrive(0);
	delay(200);
	motor[leftDrive] = -127;
	motor[rightDrive] = 127;
}
else if(auton == "field_preloads")
{
																		//Not even going to try right now...
}
else if(auton == "none")
{
																		//Self explanatory.
	displayLCDCenteredString(0, ":(");
}

//delay(14000);

//launcherEnabled = false;


//motor[leftFrontDrive] = motor[leftRearDrive] = motor[rightFrontDrive] = motor[rightRearDrive] = 127;

//delay(3000);

//motor[leftFrontDrive] = motor[leftRearDrive] = -127;
//setLauncher(0);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//																 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////
float battery = 0.0;
task usercontrol()
{
isAuton = false;
mode2 = usercontrol;
startTask(driveControl);								//Start drive/intake code. Should I move the code in that task to the usercontrol task?
//startTask(launcherMaster);
startTask(launcherMaster);							//All of this is for the launcher, and for diagnostics
startTask(bangbang);
PDenabled = false;
//startTask(PD2);
//startTask(PD);
//startTask(control);
startTask(launcherSpeed);
//startTask(launcherSpeedAverage);
//startTask(launcherSpeedAverage2);
startTask(timers);
startTask(distance);
int count = 0;
int number = 1;
// User control code here, inside the loop
string mainBattery;
string expanderBattery;
string backupBattery;
string LCDlauncherRPM;
string motorSpeed;
while (true)
{

	clearLCDLine(0);
	clearLCDLine(1);
	battery = SensorValue[expanderBatt]/280;
	sprintf(LCDlauncherRPM, "%1.2i%c", RPMAverage);
	sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0);
	sprintf(expanderBattery, "%1.2f%c", (float)SensorValue[expanderBatt]/280);
	sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0);
	sprintf(motorSpeed, "%1.2f%c", temp1);
	displayLCDString(0, 0, "RPM:");
	displayNextLCDString(LCDlauncherRPM);
	displayNextLCDString("PWR:");
	displayNextLCDString(motorSpeed);
	if(number == 1)
	{
		displayLCDString(1, 0, "Main:");
		displayNextLCDString(mainBattery);
	}
	else if(number == 2)
	{
		displayLCDString(1, 0, "Flywheel:");
		displayNextLCDString(expanderBattery);
	}
	else if(number == 3)
	{
		displayLCDString(1, 0, "Backup:");
		displayNextLCDString(backupBattery);
	}
	count ++;
	if(count == 30)
		number = 2;
	else if(count == 60)
		number = 3;
	else if(count == 90)
	{
		number = 1;
		count = 0;
	}
	delay(100);

	// This is the main execution loop for the user control program. Each time through the loop
	// your program should update motor + servo values based on feedback from the joysticks.

	// .....................................................................................
	// Insert user code here. This is where you use the joystick values to update your motors, etc.
	// .....................................................................................

	// Remove this function call once you have "real" code.
}
}
